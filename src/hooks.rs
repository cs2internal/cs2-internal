use std::{ffi::{c_void}, ptr, println};
use winapi::um::consoleapi;
use windows::{Win32::{System::LibraryLoader}, w};
use minhook_sys::{MH_CreateHook, MH_Initialize, MH_EnableHook, MH_OK};

pub mod scanner;

pub struct C_SceneEntity;

impl C_SceneEntity {
    pub const m_bIsPlayingBack: usize = 0x550; // bool
    pub const m_bPaused: usize = 0x551; // bool
    pub const m_bMultiplayer: usize = 0x552; // bool
    pub const m_bAutogenerated: usize = 0x553; // bool
    pub const m_flForceClientTime: usize = 0x554; // float32
    pub const m_nSceneStringIndex: usize = 0x558; // uint16
    pub const m_bClientOnly: usize = 0x55A; // bool
    pub const m_hOwner: usize = 0x55C; // CHandle<C_BaseFlex>
    pub const m_hActorList: usize = 0x560; // C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    pub const m_bWasPlaying: usize = 0x578; // bool
    pub const m_QueuedEvents: usize = 0x588; // CUtlVector<C_SceneEntity::QueuedEvents_t>
    pub const m_flCurrentTime: usize = 0x5A0; // float32
}

pub struct C_BaseModelEntity;

impl C_BaseModelEntity {
    pub const m_CRenderComponent: usize = 0xA18; // CRenderComponent*
    pub const m_CHitboxComponent: usize = 0xA20; // CHitboxComponent
    pub const m_bInitModelEffects: usize = 0xA68; // bool
    pub const m_bIsStaticProp: usize = 0xA69; // bool
    pub const m_nLastAddDecal: usize = 0xA6C; // int32
    pub const m_nDecalsAdded: usize = 0xA70; // int32
    pub const m_iOldHealth: usize = 0xA74; // int32
    pub const m_nRenderMode: usize = 0xA78; // RenderMode_t
    pub const m_nRenderFX: usize = 0xA79; // RenderFx_t
    pub const m_bAllowFadeInView: usize = 0xA7A; // bool
    pub const m_clrRender: usize = 0xA7B; // Color
    pub const m_vecRenderAttributes: usize = 0xA80; // C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    pub const m_bRenderToCubemaps: usize = 0xAE8; // bool
    pub const m_Collision: usize = 0xAF0; // CCollisionProperty
    pub const m_Glow: usize = 0xBA0; // CGlowProperty
    pub const m_flGlowBackfaceMult: usize = 0xBF8; // float32
    pub const m_fadeMinDist: usize = 0xBFC; // float32
    pub const m_fadeMaxDist: usize = 0xC00; // float32
    pub const m_flFadeScale: usize = 0xC04; // float32
    pub const m_flShadowStrength: usize = 0xC08; // float32
    pub const m_nObjectCulling: usize = 0xC0C; // uint8
    pub const m_nAddDecal: usize = 0xC10; // int32
    pub const m_vDecalPosition: usize = 0xC14; // Vector
    pub const m_vDecalForwardAxis: usize = 0xC20; // Vector
    pub const m_flDecalHealBloodRate: usize = 0xC2C; // float32
    pub const m_flDecalHealHeightRate: usize = 0xC30; // float32
    pub const m_ConfigEntitiesToPropagateMaterialDecalsTo: usize = 0xC38; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    pub const m_vecViewOffset: usize = 0xC50; // CNetworkViewOffsetVector
    pub const m_pClientAlphaProperty: usize = 0xC80; // CClientAlphaProperty*
    pub const m_ClientOverrideTint: usize = 0xC88; // Color
    pub const m_bUseClientOverrideTint: usize = 0xC8C; // bool
}

pub struct CGlowProperty;

impl CGlowProperty {
    pub const m_fGlowColor: usize = 0x8; // Vector
    pub const m_iGlowType: usize = 0x30; // int32
    pub const m_iGlowTeam: usize = 0x34; // int32
    pub const m_nGlowRange: usize = 0x38; // int32
    pub const m_nGlowRangeMin: usize = 0x3C; // int32
    pub const m_glowColorOverride: usize = 0x40; // Color
    pub const m_bFlashing: usize = 0x44; // bool
    pub const m_flGlowTime: usize = 0x48; // float32
    pub const m_flGlowStartTime: usize = 0x4C; // float32
    pub const m_bEligibleForScreenHighlight: usize = 0x50; // bool
    pub const m_bGlowing: usize = 0x51; // bool
}

pub unsafe extern "C" fn hook_draw_glow(glow_property: *mut CGlowProperty) -> *mut c_void {
    if glow_property.is_null() {
        return ptr::null_mut();
    }

    let original = ORIGINAL_DRAW_GLOW.unwrap();
    let result = original(glow_property);

    let owner_ptr = (glow_property as usize + C_BaseModelEntity::m_Glow) as *mut c_void;
    let owner: *mut C_BaseModelEntity = owner_ptr as *mut C_BaseModelEntity;

    let glow_color_override_ptr = (glow_property as usize + CGlowProperty::m_glowColorOverride) as *mut u32;
    let b_glowing_ptr = (glow_property as usize + CGlowProperty::m_bGlowing) as *mut bool;

    *glow_color_override_ptr = 0xFF888080; // RGBA: (128, 136, 255, 130)
    *b_glowing_ptr = true;

    result
}


static mut ORIGINAL_DRAW_GLOW: Option<unsafe extern "C" fn(*mut CGlowProperty) -> *mut c_void> = None;

pub unsafe fn demo_init() {
    consoleapi::AllocConsole();
    println!("Hello, world!");

    let client_mod = LibraryLoader::GetModuleHandleW(w!("client.dll")).unwrap();
    let addr = scanner::find_sig(client_mod, "40 53 48 83 EC 20 48 8B 54").unwrap() as usize;
    println!("Address of the function: {:x}", addr);

    if MH_Initialize() == MH_OK {
        println!("Minhook initialized");
    } else {
        eprintln!("Minhook error");
    }

    let hook_fn: unsafe extern "C" fn(*mut CGlowProperty) -> *mut c_void = hook_draw_glow;
    let original_fn = create_hook(addr as *mut c_void, hook_fn as *mut c_void);
    ORIGINAL_DRAW_GLOW = Some(std::mem::transmute(original_fn));

    if MH_EnableHook(ptr::null_mut()) == MH_OK {
        println!("Hooks enabled");
    } else {
        eprintln!("Hooks NOT enabled!");
    }
}

unsafe fn create_hook(addr: *mut c_void, hk_func: *mut c_void) -> *mut c_void {
    let mut original = ptr::null_mut();
    MH_CreateHook(addr, hk_func, &mut original);
    original
}